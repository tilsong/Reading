# 책 "자바와 JUnit을 활용한 실용주의 단위 테스트"를 읽으면서 코드와 함께 각 장을 간단히 정리해봅니다.

## 1장 
- 간단히 JUnit을 사용해보았다.
- 테스트의 각 단계를 준비(Arrange), 실행(Act), 단언(Assert)으로 구분했다. 기존에 알던 Given When Then 과는 또 다른 느낌이다. 
- 책에서는 junit 4를 기준으로 했다. 따라서 assertThat을 사용하는데, junit5의 assertEquals를 사용하는 것이 더 나을 것 같다는 생각을 했다.
<br>

## 2장
- 코드에서 발생하는 상당한 분기와 사례들로 인해, 테스트도 여러 케이스가 고려되어야 할 수 있다.
- @Before 애노테이션을 통해 반복되는 테스트의 초기화 구문 중복을 제거할 수 있다.
- 테스트 코드에 static을 사용하는 것을 피해야 한다.
- 테스트 코드에도 정리가 필요하다. (테스트 코드도 너무 길어지지 않도록.)
<br>


## 3장
- 60p, JUnit 단언
  - 테스트에 넣을 수 있는 정적 메서드 호출로, 각 단언은 어떤 조건이 참인지 검증하는 방법이다. 
    단언한 조건이 참이 아니면 테스트는 그 자리에서 멈추고 실패(failure)를 보고한다. (예외 발생 시 -> 오류 발생(Error))
- 예외 기대 시 테스트 방식 -> [/Test/T_03, /Test/MainTest] 파일 참고
  - 책이 실행을 위해 Junit4 기준이어서 Junit5와 비교하며 찾아보아야 했다..
  - junit4-> junit5 변경사항 (참고: https://imspear.tistory.com/64, https://yoon1fe.tistory.com/213)
    - 예외 처리 방식
      - 기존 4버전 -> 어노테이션 이용, @Test(expected=Exception.class)
      - 변경된 5버전 -> 구문으로 이용, Assertions.assertThrows(Exception.class, () -> {});
    - 시간 종료 속성
      - 기존 4버전 -> 어노테이션 이용, @Test(timeout = 1)
      - 변경된 5버전 -> 구문으로 이용, Assertions.assertTimeout(Duration.ofMillis(1), () -> Thread.sleep(10);
    - 초기화 메서드
      - 기존 4버전 -> @Before
      - 변경된 5버전
        - @BeforeEach -> 여러 개 선언 시, 각 메서드의 순서를 보장하지 않음
          - 각각의 @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate 가 붙은 메소드 실행 전에 실행
          - 리턴 타입으로는 반드시 void, 접근 제한자로 private 사용 금지, static으로 선언 금지
        - @BeforeAll
          - 이 어노테이션이 붙은 메소드는 모든 테스트 메소드가 실행되기 전에 한 번 실행
          - 리턴 타입으로는 반드시 void, 접근 제한자로 private 사용 금지, 반드시 static으로 선언
    - @After -> @AfterEach, @AfterClass -> @AfterAll  
    - @Category -> @Tag
<br>

## 4장 테스트 조직
- 78p, AAA로 테스트 일관성 유지
  - 준비(Arrange): 테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인.
    객체들을 생성하거나 이것과 의사소통하거나 다른 API를 호출하는 것등.
    시스템이 이미 필요로 하는 상태로 있다면 준비 상태를 생략하기도 한다.
  - 실행(Act): 테스트 코드를 실행. 보통은 단일 메서드를 호출
  - 단언(Assert): 실행한 코드가 기대한 대로 동작하는지 확인.
    실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사.
    또 테스트한 코드와 다른 객체들 사이의 의사소통을 검사하기도 함.
  - 사후(After): 테스트를 실행할 때 어떤 자원을 할당했다면 잘 정리되었는지 확인.

- 80p, 테스트를 작성할 때는 클래스 동작에 집중해야 하며, 개별 메서드를 테스트한다고 생각하면 안됨. 가령 출금 테스트를 하려면 입금 메서드가 먼저 호출되어야 함
  단위 테스트를 작성할 때는 먼저 전체적인 시각에서 시작해야함. 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작으로 테스트해야함.

- 81~82p
  - 테스트 코드는 프로덕션 코드를 사용하고, 의존한다. 
  - 테스트와 프로덕션 코드 분리 -> 대부분 테스트와 프로덕션 코드가 같은 파일 구조, 패키지명을 가지도록 한다.

- 85p, 다수의 케이스를 별도의 테스트 메서드로 분리하고,각각에 검증하는 동작을 표현하는 이름을 붙여라. 
  - 어느 동작의 문제인지 빠르게 파악가능, 실패한 테스트 해독 빠름, 모든 케이스가 실행되었음을 보장.

- 87p, 문서로서의 테스트
  - 테스트 이름 : 테스트하려는 맥락을 제안하기 보다는 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시
    - ex) doingSomeOperationGeneratesSomeResult (어떤 동작을 하면 어떤 결과가 나온다)
    - 만약 행위 주도 개발(BDD, Behavior-Drivend Development)라면, Given-when-then 양식을 사용할 수도 있다.
      -> givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs(주어진 조건에서 어떤 일을 하면 어떤 결과가 나온다.)
    - 어떤 형식이든 일관성을 유지하여, 테스트를 다른 사람에게 의미 있게 만드는 것이 중요하다.
    
- 96p, 개발을 하다가 어떤 테스트를 제외해야 할 경우, @Ignore 어노테이션을 사용할 수 있다.
  <br>

## 5장 좋은 테스트의 FIRST 속성
1. F: Fast, 빠르게
   - DB에 접속이 필요한 테스트 -> 느려짐
   - => 메모리에서 컬렉션(Map, List..)에 필요한 값들을 할당하고, DB 처럼 사용할 수 있다.
2. I: Isolate, 고립시키다
   - SRP를 테스트에서도 고려하여, 각 테스트가 작고 단일한 목적만 가질 수 있도록 해야 한다.
   - 테스트 코드는 어떤 순서나 시간에 상관없이 실행되어야 한다
   - 테스트 코드는 데이터베이스 등과데이터 의존성을 가짐으로 실패하지 않도록 해야한다.
   - 하나의 단위 테스트 코드는 다른 단위 테스트에 의존하지 않아야 한다.
   - 질문: "이들 단언이 단일 동작을 검증하도록 돕는가, 아니면 내가 새로운 테스트 이름으로 기술할 수 있는 어떤 동작을 대표하는가"
3. R: Refeat, 좋은 테스트는 반복 가능해야 한다.
   - 반복 가능한 테스트는 실행할 때마다 항상 동일한 결과를 만들어내야 한다. 따라서 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리 시켜야 한다.
    그러나 그것이 어렵다면, 목 객체(Mock)를 사용할 수도 있다. 혹은 테스트 더블
   - 반복성이 없다면, 버그가 아니라 테스트 자체의 문제를 의심해보아야 한다.
4. S: Self-validating, 스스로 검증 가능하다.
   - 테스트는 스스로 검증 가능해야 하고, 준비할 수도 있어야 한다. 
   - 테스트에 필요한 어떤 설정 단계든 자동화해야한다. 그럼에도 테스트를 실행하는데 외부 설정이 필요하다면 고립성을 위반한 것이다.
5. T: Timely, 적시에 사용한다.
   - 처음부터 테스트 잘 작성하라는 말. 나중에 하면 힘들다.

- 내 생각
  - 간단히 정리하면, 단위 테스트는 하나의 목적을 가진 현재 단위 테스트에 집중할 수 있어야 한다는 것이다.
    그러기 위해서 다른 기술(DB, 외부 시스템 등)의 관여를 지양하는 등, 외부 의존을 제거시킬 수도 있다. 이 과정에서 목 객체를 사용할 수 있다.
    결국 테스트가 어떠한 하나의 목적을 충실히 반복적으로 수행할 수 있도록 하는 것이 중요하다. 
    또한 적시에 수행되어야 한다. 한편, 테스트를 자동화하여 스스로 검증할 수 있도록 할 수 있다(CI 활용).
<br>

## 6장 무엇을 테스트할 것인가? Right BICEP
1. Right: 결과가 올바른가?
   - 행복 테스트(당연한 조건과 답을 통해 무조건 True를 반환하는 테스트)에 대해 올바른 결과값을 제공하는 지 확인.
   - 이는 현재의 요구사항에 대한 최선의 문서화라고 할 수 있다. 변경이 발생하면 적어도 현재까지 코드가 어떻게 동작했는지를 알게 된다.

2. B: Boundary conditions: 경계 조건을 고려하는가?
   - 코드에 대해 결함을 일으킬 수 있는 모서리 사례(corner case)들에 대해 테스트해야 한다.
   - ex
     - 모호하고 일관성 없는 입력 값 ex) 특수문자가 포함된 파일 이름 - "a!$##$%#$.txt"
     - 잘못된 양식의 데이터 ex) 최상위 도메인이 빠진 이메일 주소 - asdf@naver.
     - 수치적 오버플로를 일으키는 계산
     - 비거나 빠진 값 ex) 0, 0.0, "", null
     - 이성적인 기댓값을 벗어나는 값 ex) 150살의 나이
     - 중복 허용하지 않는 목록에서 중복값이 있는 경우
     - 정렬이 안된 정렬 리스트 혹은 그 반대
     - 시간 순이 맞지 않는 경우
   - 클래스 설계 시 이러한 모든 염려 사항을 고려할지 여부는 개발자에게 달려 있다. 그러나 팀에서 합의하에 불필요하게 과도한 인자를 검사하는 군더더기를 줄일 수도 있다.
     보호절을 제거한다면 코드 주석을 달거나, 코드 제한 사항을 문서화하는 테스트를 추가할 수 있다.
   - 경계 조건에서는 CORRECT를 고려할 수 있다.
     - Conformance(준수): 값이 기대한 양식을 준수하고 있는가?
     - Ordering(순서): 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
     - Range(범위): 이성적인 최솟값과 최댓값 안에 있는가?
     - Reference(참조): 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
     - Existence(존재): 값이 존재하는가(널이 아니거나 0이 아니거나 집합에 존재하는가 등)?
     - Cardinality(기수): 정확히 충분한 값이 있는가?
     - Time(절대적 혹은 상대적 시간): 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?

3. I: Inversion relationship: 역 관계를 검사할 수 있는가?
    - 논리적인 역관계를 적용하여 행동을 검사할 수 있다. (모든 경우에 포함되지는 않는다)
    - 기존 로직의 도치가 있는지 확인하고 이를 검사한다.
    - ex) 제곱근 동작을 검사하기 위하여 (제곱근(a*a)* 제곱근(a*a)) == a*a) 코드를 테스트할 수 있다.
    - 교차 검사는 모든 요소를 더하고 균형이 맞는지 확인하는 방법이다.
4. C: Cross-check: 다른 수단을 활용하여 교차 검사할 수 있는가?
    - 기존 코드가 아닌 다른 코드(성능이 떨어지거나 하는 사항이 있지만 기존 로직과 같은 결과를 낼 수 있는 코드)로 실행했을 때에도 같은 결과를 도출하는지 여부를 확인한다.
    - 클래스의 서로 다른 조각 데이터를 사용하여 모든 데이터가 합산되는지 확인해보기
      - ex) 도서 대출 시스템에서,대출된 도서와 선반에 있는 도서 개수를 합하면, 총 도서의 수량과 일치해야 한다. 교차 검사가 가능해야 한다.
5. E: Error conditions: 오류 조건을 강제로 일어나게 할 수 있는가?
    - 오류 조건이 일어날 수 있는 상황에 대해 생각해보고, 이를 적절한 범위 내에서 테스트해본다.
        - ex) 메모리가 가득 찰 때, 벽시계 시간에 대한 문제들, 네트워크 가용성 및 오류들 등..
6. P: Performance characteristics: 성능 조건은 기준에 부합하는가?
    - 단위 성능 측정 테스트는, 변경 사항을 만들 때 기준점으로 활용하는 것이 적절하다. 섣불리 추측만으로 성능 문제에 대응하기보다는
      단위 테스트를 설계하여 진짜 문제가 어디 있으며 예상한 변경 사항으로 어떤 차이가 생겼는지 파악하는 것이 중요하다.
    - 모든 성능 최적화 시도는 실제 데이터로 해야 하며 추측을 기반으로 해서는 안된다.

- 내 생각
    - 무엇을 테스트하는지에 대해 다룬 장이었다. 요구사항을 반영한 행복 테스트, 경계값 테스트, 역 검사 및 오류 테스트 등이 테스트로 만들어질 수 있는 항목이 될 수 있다.
      코드의 성능을 언제 보는 것인지도 다루었다.
<br>

## 10장 목 객체 사용
### 번거로운 동작을 스텁으로 대체
- 스텁과 목을 통해 의존하는 객체의 행동을 흉내내어 테스트에 사용할 수 있다.
- 스텁: 테스트 용도로 하드 코딩한 값을 반환하는 구현체. json 등의 값을 반환하게 됨. 
  - 인터페이스에 대한 구현체로 스텁을 만들 수 있음. 혹은 생성자 대신 세터 메서드를,혹은 팩토리 메서드나 추상 팩토리를 도입할 수도 있다.
  - 스텁에 인자 검증 로직을 추가할 수 있다. 
    => 목에 가깝게 됨. 목은 의도적으로 흉내 낸 동작을 제공하고 수신한 인자가 모두 정상인지 여부를 검증하는 일을 하는 테스트 구조물이다.
- 목(Mock) 라이브러리를 사용할 수 있다. ex) 모키토
  - 이 때, 목을 사용한 테스트는 진행하길 원하는 내용을 분명하게 기술해야 한다. 목이 실제 동작을 대신하기 때문이다.
  - 목을 사용한 코드는 프로덕션 코드를 직접 테스트한 것이 아니므로, 적절한 상위 테스트가 있어야 한다.


  <br>

## 12장 테스트 주도 개발
- TDD는 작성하려는 코드를 어떻게 테스트할지 먼저 고민해보는 것이다. 코드를 작성한 후에 어떻게 테스트할지 고민하기보다 작성할 코드를 묘사하는 테스트를 설계해야 한다.
- TDD에서 단위 테스트는 시스템의 모양을 잡고 통제하는 도구로 활용될 수 있다. 이 때 소프트웨어 설계가 더 좋아질 것이다.
- TDD는 세 부분의 사이클로 구성된다. 테스트-코드-리팩토링
  1. 실패하는 테스트 코드 작성하기 -> 기대하는 동작이 아직 시스템에 존재하지 않음을 보여준다.
  2. 테스트 통과시키기 -> 테스트가 나타내는 명세를 정확히 코딩한다. 
  3. 이전 두 단계에서 추가되거나 변경된 코드 개선하기 -> 테스트 코드를 정리한다.

