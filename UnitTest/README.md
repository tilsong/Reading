# 책 "자바와 JUnit을 활용한 실용주의 단위 테스트"를 읽으면서 코드와 함께 각 장을 간단히 정리해봅니다.

## 1장 
- 간단히 JUnit을 사용해보았다.
- 테스트의 각 단계를 준비(Arrange), 실행(Act), 단언(Assert)으로 구분했다. 기존에 알던 Given When Then 과는 또 다른 느낌이다. 
- 책에서는 junit 4를 기준으로 했다. 따라서 assertThat을 사용하는데, junit5의 assertEquals를 사용하는 것이 더 나을 것 같다는 생각을 했다.

## 2장
- 코드에서 발생하는 상당한 분기와 사례들로 인해, 테스트도 여러 케이스가 고려되어야 할 수 있다.
- @Before 애노테이션을 통해 반복되는 테스트의 초기화 구문 중복을 제거할 수 있다.
- 테스트 코드에 static을 사용하는 것을 피해야 한다.
- 테스트 코드에도 정리가 필요하다. (테스트 코드도 너무 길어지지 않도록.)

## 3장
- 60p, JUnit 단언
  - 테스트에 넣을 수 있는 정적 메서드 호출로, 각 단언은 어떤 조건이 참인지 검증하는 방법이다. 
    단언한 조건이 참이 아니면 테스트는 그 자리에서 멈추고 실패(failure)를 보고한다. (예외 발생 시 -> 오류 발생(Error))
- 예외 기대 시 테스트 방식 -> [/Test/T_03, /Test/MainTest] 파일 참고
  - 책이 실행을 위해 Junit4 기준이어서 Junit5와 비교하며 찾아보아야 했다..
  - junit4-> junit5 변경사항 (참고: https://imspear.tistory.com/64, https://yoon1fe.tistory.com/213)
    - 예외 처리 방식
      - 기존 4버전 -> 어노테이션 이용, @Test(expected=Exception.class)
      - 변경된 5버전 -> 구문으로 이용, Assertions.assertThrows(Exception.class, () -> {});
    - 시간 종료 속성
      - 기존 4버전 -> 어노테이션 이용, @Test(timeout = 1)
      - 변경된 5버전 -> 구문으로 이용, Assertions.assertTimeout(Duration.ofMillis(1), () -> Thread.sleep(10);
    - 초기화 메서드
      - 기존 4버전 -> @Before
      - 변경된 5버전
        - @BeforeEach -> 여러 개 선언 시, 각 메서드의 순서를 보장하지 않음
          - 각각의 @Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate 가 붙은 메소드 실행 전에 실행
          - 리턴 타입으로는 반드시 void, 접근 제한자로 private 사용 금지, static으로 선언 금지
        - @BeforeAll
          - 이 어노테이션이 붙은 메소드는 모든 테스트 메소드가 실행되기 전에 한 번 실행
          - 리턴 타입으로는 반드시 void, 접근 제한자로 private 사용 금지, 반드시 static으로 선언
    - @After -> @AfterEach, @AfterClass -> @AfterAll  
    - @Category -> @Tag

## 4장 테스트 조직
- 78p, AAA로 테스트 일관성 유지
  - 준비(Arrange): 테스트 코드를 실행하기 전에 시스템이 적절한 상태에 있는지 확인.
    객체들을 생성하거나 이것과 의사소통하거나 다른 API를 호출하는 것등.
    시스템이 이미 필요로 하는 상태로 있다면 준비 상태를 생략하기도 한다.
  - 실행(Act): 테스트 코드를 실행. 보통은 단일 메서드를 호출
  - 단언(Assert): 실행한 코드가 기대한 대로 동작하는지 확인.
    실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사.
    또 테스트한 코드와 다른 객체들 사이의 의사소통을 검사하기도 함.
  - 사후(After): 테스트를 실행할 때 어떤 자원을 할당했다면 잘 정리되었는지 확인.

- 80p, 테스트를 작성할 때는 클래스 동작에 집중해야 하며, 개별 메서드를 테스트한다고 생각하면 안됨. 가령 출금 테스트를 하려면 입금 메서드가 먼저 호출되어야 함
  단위 테스트를 작성할 때는 먼저 전체적인 시각에서 시작해야함. 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작으로 테스트해야함.

- 81~82p
  - 테스트 코드는 프로덕션 코드를 사용하고, 의존한다. 
  - 테스트와 프로덕션 코드 분리 -> 대부분 테스트와 프로덕션 코드가 같은 파일 구조, 패키지명을 가지도록 한다.

- 85p, 다수의 케이스를 별도의 테스트 메서드로 분리하고,각각에 검증하는 동작을 표현하는 이름을 붙여라. 
  - 어느 동작의 문제인지 빠르게 파악가능, 실패한 테스트 해독 빠름, 모든 케이스가 실행되었음을 보장.

- 87p, 문서로서의 테스트
  - 테스트 이름 : 테스트하려는 맥락을 제안하기 보다는 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시
    - ex) doingSomeOperationGeneratesSomeResult (어떤 동작을 하면 어떤 결과가 나온다)
    - 만약 행위 주도 개발(BDD, Behavior-Drivend Development)라면, Given-when-then 양식을 사용할 수도 있다.
      -> givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs(주어진 조건에서 어떤 일을 하면 어떤 결과가 나온다.)
    - 어떤 형식이든 일관성을 유지하여, 테스트를 다른 사람에게 의미 있게 만드는 것이 중요하다.
    
- 96p, 개발을 하다가 어떤 테스트를 제외해야 할 경우, @Ignore 어노테이션을 사용할 수 있다.

## 5장 좋은 테스트의 FIRST 속성
1. F: Fast, 빠르게
   - DB에 접속이 필요한 테스트 -> 느려짐
   - => 메모리에서 컬렉션(Map, List..)에 필요한 값들을 할당하고, DB 처럼 사용할 수 있다.
2. I: Isolate, 고립시키다
   - SRP를 테스트에서도 고려하여, 각 테스트가 작고 단일한 목적만 가질 수 있도록 해야 한다.
   - 테스트 코드는 어떤 순서나 시간에 상관없이 실행되어야 한다
   - 테스트 코드는 데이터베이스 등과데이터 의존성을 가짐으로 실패하지 않도록 해야한다.
   - 하나의 단위 테스트 코드는 다른 단위 테스트에 의존하지 않아야 한다.
   - 질문: "이들 단언이 단일 동작을 검증하도록 돕는가, 아니면 내가 새로운 테스트 이름으로 기술할 수 있는 어떤 동작을 대표하는가"
3. R: Refeat, 좋은 테스트는 반복 가능해야 한다.
   - 반복 가능한 테스트는 실행할 때마다 항상 동일한 결과를 만들어내야 한다. 따라서 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리 시켜야 한다.
    그러나 그것이 어렵다면, 목 객체(Mock)를 사용할 수도 있다. 혹은 테스트 더블
   - 반복성이 없다면, 버그가 아니라 테스트 자체의 문제를 의심해보아야 한다.
4. S: Self-validating, 스스로 검증 가능하다.
   - 테스트는 스스로 검증 가능해야 하고, 준비할 수도 있어야 한다. 
   - 테스트에 필요한 어떤 설정 단계든 자동화해야한다. 그럼에도 테스트를 실행하는데 외부 설정이 필요하다면 고립성을 위반한 것이다.
5. T: Timely, 적시에 사용한다.
   - 처음부터 테스트 잘 작성하라는 말. 나중에 하면 힘들다.

- 내 생각
  - 간단히 정리하면, 단위 테스트는 하나의 목적을 가진 현재 단위 테스트에 집중할 수 있어야 한다는 것이다.
    그러기 위해서 다른 기술(DB, 외부 시스템 등)의 관여를 지양하는 등, 외부 의존을 제거시킬 수도 있다. 이 과정에서 목 객체를 사용할 수 있다.
    결국 테스트가 어떠한 하나의 목적을 충실히 반복적으로 수행할 수 있도록 하는 것이 중요하다. 
    또한 적시에 수행되어야 한다. 한편, 테스트를 자동화하여 스스로 검증할 수 있도록 할 수 있다(CI 활용).




